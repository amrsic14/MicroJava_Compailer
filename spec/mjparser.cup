package rs.ac.bg.etf.pp1;

import rs.ac.bg.etf.pp1.ast.*;

import org.apache.log4j.*;
import java_cup.runtime.*;

parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, ASSIGN, VOID, LSQBRACE, RSQBRACE, INC, DEC, OR, AND, MINUS, DOT;
terminal MUL, DIV, MOD;
terminal Integer NUMCONST ;
terminal Character CHARCONST;
//terminal Boolean BOOLCONST;
terminal String IDENT;
terminal IF, ELSE, FOR, BREAK, CONTINUE, READ;
terminal CONST, NEW;
terminal EQUAL, NOTEQUAL, GREATEREQUAL, LESSEQUAL, GREATER, LESS;
terminal TRUE, FALSE;

nonterminal MethodDeclList, VarDecl, DeclList, ConstDecl;
nonterminal FormalParamList, FormalParamDecl, FormPars; 
nonterminal StatementList, Statement, Addop, Relop, Mulop;
nonterminal Else, ForSemi, And, Or, IfLeftParen;
nonterminal ConstList, Const, IfCondition;
nonterminal VarList, Var, OnlyArrayDesignator;
nonterminal DesignatorStatement, Condition, OptionalDesignatorStatement, OptionalCondition, OptionalExpression, ForRightParen, ActParsStartLeftParen;
nonterminal Assignop, OptionalActPars, ActParsList, ActPar;
nonterminal CondTerm, CondFact;
//nonterminal BoolConst;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName, BoolConst; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Expr, Term, Factor, VarDeclList; 

precedence left ELSE;

Program ::= (Program) PROGRAM ProgName DeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:pName;

DeclList ::=(DeclListConst) DeclList ConstDecl
			|
			(DeclListVar) DeclList VarDecl
			|
			(NoDeclList)
			;

ConstDecl ::= (ConstDecl) CONST Type ConstList SEMI;

ConstList ::=(Constants) ConstList COMMA Const
			|
			(Constant) Const
			;

Const ::= (ConstNum) IDENT:name ASSIGN NUMCONST:value
		|
		(ConstChar) IDENT:name ASSIGN CHARCONST:value
		|
		(ConstBool) IDENT:name ASSIGN BoolConst:value
		;

BoolConst ::= (True) TRUE
			|
			(False) FALSE
			;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl  
				|
				(NoVarDecl)
				;

VarDecl ::= (VarDeclNoError) Type VarList SEMI
			|
			(VarDeclError) Type error SEMI
			;

VarList ::= (SameTypeVars) VarList COMMA Var
			|
			(SameTypeVarsError) error COMMA Var
			|
			(SingleSameTypeVar) Var
			;

Var ::= (VarArray) IDENT:name LSQBRACE RSQBRACE
		|
		(SingleVar) IDENT:name 
		;

Type ::= (Type) IDENT:typeName
		;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDecl)
				;

MethodDecl ::= (MethodDeclRegular) MethodTypeName LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			|
			(MethodDeclError) MethodTypeName LPAREN error RPAREN VarDeclList LBRACE StatementList RBRACE
			;

MethodTypeName ::= (MethodRetTypeName) Type:retType IDENT:methName
				|
			   	(MethodRetVoidName) VOID:retType IDENT:methName
				;

FormPars ::= (FormParams) FormalParamList 
			 |
			 (NoFormParam);

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
					|
					(FormalParamDeclsError) error COMMA FormalParamDecl
					|
					(SingleFormalParamDecl) FormalParamDecl
					;

FormalParamDecl ::= (FormalParamDeclSingle) Type IDENT:name 
					|
					(FormalParamDeclArray) Type IDENT:name LSQBRACE RSQBRACE 
					;

StatementList ::= (Statements) StatementList Statement 
				|
				(NoStmt)
				;

Statement ::= (StatementDesignatorStatement) DesignatorStatement SEMI
			  |
			  (StatementIf) IF IfLeftParen IfCondition RPAREN Statement
			  |
			  (StatementIfElse) IF IfLeftParen IfCondition RPAREN Statement Else Statement
			  |
			  (StatementFor) FOR LPAREN OptionalDesignatorStatement ForSemi OptionalCondition SEMI OptionalDesignatorStatement ForRightParen Statement
			  |
			  (StatementForError) FOR LPAREN OptionalDesignatorStatement ForSemi error SEMI OptionalDesignatorStatement ForRightParen Statement
			  |
			  (StatementBreak) BREAK SEMI
			  |
			  (StatementContinue) CONTINUE SEMI
			  |
			  (StatementReturn) RETURN OptionalExpression SEMI
			  |
			  (StatementRead) READ LPAREN Designator RPAREN SEMI
			  |
			  (StatementPrintNoConst) PRINT LPAREN Expr RPAREN SEMI
			  |
			  (StatementPrintWithConst) PRINT LPAREN Expr COMMA NUMCONST RPAREN SEMI
			  |
			  (StatementMulty) LBRACE StatementList RBRACE
			  ;

IfLeftParen ::= (IfLeftParen) LPAREN; 

ForSemi ::= (ForSemi) SEMI;		  

IfCondition ::= (IfCondition) Condition;

Else ::= (Else) ELSE;

ForRightParen ::= (ForRightParen) RPAREN;

OptionalDesignatorStatement ::= (WithDesignatorStatement) DesignatorStatement
								|
								(NoDesignatorStatement)
								;

DesignatorStatement ::= (DesignatorStatementAssignop) Designator Assignop Expr
						|
						(DesignatorStatementAssignopError) Designator Assignop error
						|
						(DesignatorStatementOptAct) Designator ActParsStartLeftParen OptionalActPars RPAREN
						|
						(DesignatorStatementINC) Designator INC 
						|
						(DesignatorStatementDEC) Designator DEC
						;

ActParsStartLeftParen ::= (ActParsStartLeftParen) LPAREN;

OptionalActPars ::= (WithActPars) ActParsList 
				|
				(NoActPars)
				;

ActParsList  ::= (MultyActPars) ActParsList COMMA ActPar
				|
				(SingleActPars) ActPar
				;

ActPar ::= (ActPar) Expr;

OptionalCondition ::= (WithCondition) Condition  
					|
					(NoCondition)
					;

Condition ::= (MultyCondTerm) Condition Or CondTerm
			|
			(SingleCondTerm) CondTerm
			;

CondTerm ::= (MultyCondFact) CondTerm And CondFact
			|
			(SingleCondFact) CondFact
			;

And ::= (And) AND;

Or ::= (Or) OR;

CondFact ::= (RelopCondFact) Expr Relop Expr
			 |
			 (ExprCondFact) Expr 
			 ;

OptionalExpression ::= (WithExpression) Expr
				|
				(NoExpression)
				;		

Expr ::= (MultyTerms) Expr Addop Term 
		|
		(PlusTerm) Term 
		|
		(MinusTerm) MINUS Term 
		;

Term ::= (MulopFactorTerm) Term Mulop Factor
		 |
		 (SingleFactorTerm) Factor 
		 ;

Factor ::= (DesignatorWithActFactor) Designator ActParsStartLeftParen OptionalActPars RPAREN 
		   |
		   (DesignatorWithoutActFactor) Designator
		   |
		   (NumconstFactor) NUMCONST 
		   |
		   (CharconstFactor) CHARCONST 
		   |
		   (BoolconstFactor) BoolConst
		   |
		   (NewTypeExprFactor) NEW Type LSQBRACE Expr RSQBRACE 
		   |
		   (NewTypeFactor) NEW Type 
		   |
		   (ParenthesesFactor) LPAREN Expr RPAREN
           ;

Designator ::= (DesignatorArray) OnlyArrayDesignator LSQBRACE Expr RSQBRACE
			|
			(DesignatorClass) Designator DOT IDENT:name
			|
			(SimpleDesignator) IDENT:name
			;

OnlyArrayDesignator ::= (OnlyArrayDesignator) Designator;

Assignop ::= (Assignop) ASSIGN;

Relop ::= (RelopEqual) EQUAL
		  |
		  (RelopNotEqual) NOTEQUAL
		  |
		  (RelopGreater) GREATER
		  |
		  (RelopGreaterEqual) GREATEREQUAL
		  |
		  (RelopLess) LESS
		  |
		  (RelopLessEqual) LESSEQUAL
		  ;

Addop ::= (AddopPlus) PLUS 
		  |
		  (AddopMinus) MINUS
		  ;

Mulop ::= (MulopMul) MUL
		  |
		  (MulopDiv) DIV 
		  |
		  (MulopMod) MOD
		  ;